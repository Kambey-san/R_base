# Урок 5. Статистический анализ в R. Тест гипотезы/ ДЗ
'
Доверительный интервал
Z-критерий для построения доверительного интервала:

1. Критерий Z является более предпочтительным в том случае, если известно стандартное отклонение генеральной совокупности
2. Имеется достаточно большой объем выборки
3. Данные хорошо приближены к нормальному распределению
'
install.packages("rafalib")
install.packages("effsize")
install.packages("BSDA")
install.packages("pwr")
library(dplyr)
library(rafalib)
library(effsize)
library(BSDA)
library(pwr)



'
Задача: С помощью 95% доверительного интервала оценить среднее арифметическое нормально распределенной генеральной совокупности,
зная что ее стандартное отклонение равно 3, а объем выборки равен 50
'
set.seed(4 )
samp <- rnorm(50,7,3)
samp

'
Определение статистики для оценки интервала

ЦПТ хорошо работает от 30 и выше, известно стандартное отклонение генеральной совокупности
и данные хорошо приближены к нормальному распределению, измерения независимы, поэтому используем критерий Z
'

qqnorm(samp)
qqline(samp)

Z <- qnorm(0.975) # 95% CI
Z

SE <- 3/sqrt(50)
SE

lolv <- mean(samp) - 2*SE
uplv <- mean(samp) + 2*SE
CI <- c(lolv,uplv)
CI

# Генерируя выборку, мы представляли, будто не знаем среднее арифметическое.
# Определили доверительный интервал и можно проверить трушность
7 >= CI[1] & 7 <= CI[2]


'
t- критерий для построения доверительного интервала

1. Неизвестно стандартное отклонение генеральной совокупности
2. Выборка небольшого объема
3. Соблюдается условие нормальности и независимости наблюдений для первых двух пунктов
Идея 95 % интервала состоит в том, что 95 % интервалов должны захватывать истинное среднее арифметическое генеральной совокупности
'
# Сравним как работает ЦПТ на выборках разных объемов
bigpar(1,3)
set.seed(3)

plot(7 + c(-4,4), c(1,1), type="n", xlab="mu", ylab="доверительные интервалы", ylim=c(1,100), main="N=10")
abline(v=7, col="brown", lwd=2)
for (i in 1:100) {
  sam <- rnorm(10,7,3)
  SE <- sd(sam)/sqrt(10)
  CI <- c(mean(sam)-Z*SE, mean(sam)+2*SE)
  catch <- 7 >= CI[1] & 7 <= CI[2]
  color <- ifelse(catch, "blue", "red")
  lines(CI, c(i,i), col=color, lwd=2)
}

plot(7 + c(-4,4), c(1,1), type="n", xlab="mu", ylab="доверительные интервалы", ylim=c(1,100), main="N=50")
abline(v=7, col="brown", lwd=2)
for (i in 1:100) {
  sam <- rnorm(50,7,3)
  SE <- sd(sam)/sqrt(50)
  CI <- c(mean(sam)-Z*SE, mean(sam)+2*SE)
  catch <- 7 >= CI[1] & 7 <= CI[2]
  color <- ifelse(catch, "blue", "red")
  lines(CI, c(i,i), col=color, lwd=2)
}

plot(7 + c(-4,4), c(1,1), type="n", xlab="mu", ylab="доверительные интервалы", ylim=c(1,100), main="N=100")
abline(v=7, col="brown", lwd=2)
for (i in 1:100) {
  sam <- rnorm(100,7,3)
  SE <- sd(sam)/sqrt(100)
  CI <- c(mean(sam)-Z*SE, mean(sam)+2*SE)
  catch <- 7 >= CI[1] & 7 <= CI[2]
  color <- ifelse(catch, "blue", "red")
  lines(CI, c(i,i), col=color, lwd=2)
}

'
Оставим теперь тот же set.seed(3), но теперь для выборки объемом 10 будем использовать распределение Стьюдента

Если объем выборки меньше 15, требуется, чтобы данные были приближены к нормальному распределению. 
Проверим это требование с помощью qq-графика
'
set.seed(3)

sam <- rnorm(10,7,3)
mypar(1,1)
qqnorm(sam, col=1, lwd=2)
qqline(sam, col="red")

# Сравним интервалы для t и z критериев при небольших выборках
bigpar(1,2)
set.seed(3)
t <- qt(0.975, 9)

plot(7 + c(-4,4), c(1,1), type="n", xlab="mu", ylab="доверительные интервалы", ylim=c(1,100), main="N=10, t-критерий")
abline(v=7, col="brown", lwd=2)
for (i in 1:100) {
  sam <- rnorm(10,7,3)
  SE <- sd(sam)/sqrt(10)
  CI <- c(mean(sam)-Z*SE, mean(sam)+2*SE)
  catch <- 7 >= CI[1] & 7 <= CI[2]
  color <- ifelse(catch, "blue", "red")
  lines(CI, c(i,i), col=color, lwd=2)
}

plot(7 + c(-4,4), c(1,1), type="n", xlab="mu", ylab="доверительные интервалы", ylim=c(1,100), main="N=10, z-критерий")
abline(v=7, col="brown", lwd=2)
for (i in 1:100) {
  sam <- rnorm(10,7,3)
  SE <- sd(sam)/sqrt(10)
  CI <- c(mean(sam)-Z*SE, mean(sam)+2*SE)
  catch <- 7 >= CI[1] & 7 <= CI[2]
  color <- ifelse(catch, "blue", "red")
  lines(CI, c(i,i), col=color, lwd=2)
}

Z

t

c(mean(sam)-Z*SE, mean(sam)+Z*SE)

c(mean(sam)-t*SE, mean(sam)+t*SE)


'
Вернемся к реальному набору данных Cardiovascular Disease
'
library(httr)
# Скачаем файл "cardio_train.csv"
filename <- "cardio_train.csv"
url <- "https://drive.google.com/uc?authuser=0&id=1qPKIRO3GfGNQK7rUFpZQWQRaNhTjHvJP&export=download"
GET(url, write_disk(filename, overwrite=TRUE))

df <- read.csv(filename, sep=";")
head(df, 3)

tidy_set <- df %>% filter((ap_lo<200 & ap_lo > 20) & (ap_hi<300 & ap_hi>40))
head(tidy_set)

# Задача: оценить среднее диастолическое давление мужчин и женщин с помощью 95% доверительного интервала
head(tidy_set[tidy_set$ap_hi < tidy_set$ap_lo,])

tidy_set_ <- tidy_set[tidy_set$ap_hi > tidy_set$ap_lo,]
dim(tidy_set_)
dim(tidy_set)
women_ <- tidy_set_$ap_lo[tidy_set_$gender==1]
men_ <- tidy_set_$ap_lo[tidy_set_$gender==2]

'
Убедимся в предположении о нормальности
Исходя из того, что сигма неизвестна и данные приближены к нормальному распределению
(хотя верхние и нижние значения лежат дальше, чем предполагалось нормальным распределением), 
можон использовать t-критерий.
'
mypar(1,2)
qqnorm(men_, main="мужчины")
qqline(men_)
qqnorm(women_, main="женщины")
qqline(women_)

# С помощью функции summarize(), можно построить сводную таблицу, где будут подсчитаны нужные статистические значения
tidy_set_ %>% group_by(gender) %>% summarise(
  mu=mean(ap_lo),
  k=qt(0.975, length(ap_lo)-1),
  se=sd(ap_lo)/sqrt(length(ap_lo)),
  lowlevel=mean(ap_lo)-k*se,
  hilevel=mean(ap_lo)+k*se
)

infer <- tidy_set_ %>% group_by(gender) %>% summarise(
  mu=mean(ap_lo),
  k=qt(0.975, length(ap_lo)-1),
  se=sd(ap_lo)/sqrt(length(ap_lo)),
  lowlevel=mean(ap_lo) - k*se,
  hilevel=mean(ap_lo) + k*se
)
infer

ci_w <- c(infer[1, 5], infer[1,6])
ci_w <- as.numeric(c(infer[1,5], infer[-1,6]))
ci_w

ci_m <- c(infer[2,5], infer[2,6])
ci_m <- as.numeric(ci_m)
ci_m

# Графически интервальные оценки для мужчин и женщин
plot(
  mean(women_), col=2, lwd=2, xlim=c(0.5,2.5), ylim=c(78, 84),
  ylab="среднее диастолическое давление", main="интервальная оценка"
)
interval <- c(80.75, 80.92)
lines(x=c(1,1), y=interval, col="red", lwd=3)
points(1.5,mean(men_), col=3, lwd=2)
interval_1 <- c(82.05, 82.29)
lines(x=c(1.5,1.5), y=interval_1, col="blue", lwd=3)
legend("topleft", c("women","men"), fill=c("red","blue"))



'
Мы выбираем поставщика. Поставщик заявляет ,что он изготавливает детали размером 9 см и стандартным отклонением 0.3 см. 
Мы взяли 20 деталей, измерили их и получили выборку "post". Проверить односторонним тестом, что истинное среднее не равно 9 см.
(для простоты понимания и расчета сначала проведем односторонний тест, хотя правильно - провести двусторонний)
'
post <- c(
  8.812, 9.055, 8.749, 9.479, 9.099, 8.754, 9.146, 9.221, 9.173, 8.908,
  9.454, 9.117, 8.814, 8.336, 9.337, 8.987, 8.995, 9.283, 9.246, 9.178
)

# 1) Убеждаемся, что наблюдения независимы
# 2) Если небольшой объем выборки, проверяем на нормальность данные с помощью qq-графика
qqnorm(post)
qqline(post, col="red")

# 3) Установим гипотезу:
'
H0 : mu = mu0
H1 : mu > mu0
'

# 4) Рассчитаем мощность теста:
'
Предположим, что минимальная разница между измеренным средним и средним, заявленным производителем,
которое мы хотим выявить при тестировании гипотезы 0.3 см. Известно стандартное отклонение 0.3 и альфа 0.05.
'
# Произведем расчет мощности теста
# Размер эффекта, значения ниже которого, мы считаем, не имеют для нас смысла
# ES (effect size) = 0.3 см
# Рассчитываем Z.0 для альфа = 0.05
qnorm(0.95)

# Вычисляем значение среднего, соответствующего Z.0 = 1.645
sig <- signif(0.3 / sqrt(20), 2)
sig

sig_1 <- 9.0 + 1.645 * sig
sig_1

# Вычислим значение Z.1 (для Н1)
z_1 <- (sig_1 - 9.3) / sig
z_1

# Вычисляем мощность теста
1 - pnorm(z_1)

'
В этой задаче было бы правильнее проводить двусторонний тест, т.е.

H1: Mu != Mu.0

При этом нужно учитывать, что у одностороннего теста мощность больше, чем у двустороннего

Для тестирования гипотезы воспользуемся функцией z.test() из пакета "BSDA". 
Выбираем критерий Z, поскольку он более предпочтителен при неизвестном стандартном отклонении
'

# 5.1) Для начала сделаем односторонний тест
z.test(post, alternative="g", mu=9, sigma.x=0.3)

# Рассчитаем наблюдаемое вручную и сравним со значением слева, что предоставляет функция
(mean(post)-9)*sqrt(20)/3

# 5.2) Поведем тест гипотезы в R, только теперь двусторонний
# Сравним значения p-value для одностороннего и двустороннего теста:
z.test(post, alternative="g", mu=9, sigma.x=0.3)

z.test(post, alternative="two.sided", mu=9, sigma.x=0.3)

'
6) Вывод:
6.1) Для одностороннего теста:

Гипотеза H0 верна (среднее арифметическое = 9 см) на уровне значимости 0.05

p-value = 0.1971

6.2) Для двустороннего теста:

Гипотеза Н0 верна на уровне значимости 0.05

p-value = 0.3942
'


'
Для тестирования гипотезы с небольшими выборками(< 30) используют t-test, а также если неизвестно стандартное отклонение
T-test:
1. Одновыборочный - тест Стьюдента

2. Двухвыборочный:

2.1) Выборки с одинаковой дисперсией – тест Стьюдента

2.2) Выборки с разными дисперсиями – тест Уэлча
'
t.test(sample(men_, 20), sample(women_, 20), var.equal = TRUE)

t.test(sample(men_, 20), sample(women_, 20), var.equal = FALSE)


# t-test для независимых выборок
'
Сравним верхнее и нижнее диастолическое давление между мужчинами и женщинами (women_, men_)

1. Посмотрим на данные: достаточно большой объем выборок, независимые измерения, независимые выборки. Стандартное отклонение неизвестно. С помощью qq-графика проверяем на нормальность. Все в порядке. Следовательно, однозначно используем t-критерий. Предполагаем, что выборки с разной дисперсией.

2. Формулируем нулевую и альтернативную гипотезы:

Н0: mu = mu0

H1: mu != mu0

3. Устанавливаем уровень значимости 
 a = 0.05

4. Рассчитываем мощность теста (1 - B) 
'

# 4.1) Для начала рассчитаем статистику d Коэна
# Это способов оценить размер эффекта. Показывает сколько стандартных общих отклонений между средними двух групп

s_pool <- sqrt(
  ((length(women_)-1)*var(women_)+(length(men_)-1)*var(men_)) / 
    (length(women_)+length(men_)-2)
)
d <- (mean(men_)-mean(women_))/s_pool
d

d <- cohen.d(d=men_, women_)
d

d <- d$estimate
d

# значение, полученное с помощью функции cohen.d(), совпадает с вычисленным вручную


'4.2) Поскольку выборки разного размера, для расчета мощности используем функцию pwr.t2n.test() из пакета "pwr"'
# В противном случае можем воспользоваться pwr.t.test().

pwr.t2n.test(n1=length(women_), n2=length(men_), d=d, sig.level=0.05, alternative="two.sided")

'5) С помощью функции t.test, протестируем гипотезу'
t.test(men_, women_, alternative="two.sided")

'6) Вывод: получено очень маленькое значение p-value,
и следует отвергнуть нулевую гипотезу. Но с увеличением выборки p-value будет уменьшаться

Очень маленькие значения p-value не представляют уже научного интереса. 
Очень большие выборки позволяют обнаружить очень слабые различия, которые не несут научного смысла.'

# Чтобы было ясно, что мы нашли было бы правильно сообщить размер эффекта в % и его доверительный интервал,
# рассчитанные следующим образом:
((mean(men_)-mean(women_)) / mean(women_)) * 100  # размер эффекта в %

t <- t.test(men_, women_, alternative="two.sided")
ci <- t$conf.int
ci / mean(women_) * 100  # доверительный интервал для ES

attr(ci, "conf.level")

'Предположим мы хотим обнаружить сильный эффект. Cohens d = 0.8.
Посчитаем, сколько нужно выборок для обнаружения сильного эффекта'
pwr.t2n.test(n1=20, power=0.8, d=0.8, sig.level=0.05, alternative="two.sided")

# не обнаружили сильного эффекта
t.test(sample(men_, 20), sample(women_, 35))

# Вывод: H0 верна

# Одновыборочный t.test:
t.test(sample(men_, 20))

# Двухвыборочный t.test с зависимыми выборками:
t.test(
  sample(men_, 20), sample(women_, 20), 
  alternative="two.sided", paired=TRUE
)

